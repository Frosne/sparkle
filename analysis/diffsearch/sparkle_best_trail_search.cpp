/*
 * Search for the optimal differential trails of the ARXbox of SPARKLE
 * Copyright (C) 2019 SPARKLEgrupp
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
/******************************************************************************
 *
 * sparkle_best_trail_search
 *
 ******************************************************************************/

#include <cmath>
#define TRAIL_SEARCH 1
#include "defs.h"
#include "xdp_add.h"
#include "trail.h"

int g_Bn;
Trail trail;
uint64_t nNodes;
#ifdef STATS
uint64_t nNodesPerRound[100];
uint64_t nNodesPerRoundPerIbit[100][WORD_SIZE + 1];
uint64_t nPathsPerRoundPerIbit[100][WORD_SIZE + 1];
#endif

/* forward declaration */
bool sparkle_best_trail_search_i(unsigned int iround, unsigned int ibit, WORD_T alpha, WORD_T beta, WORD_T gamma);

/* unrolled search for iround > 1 and ibit = 0..7
   Note that this file was generated by a script
 */
#include "sparkle_best_trail_search_ibit0.cpp"

/* the actual search function */
bool sparkle_best_trail_search_i(unsigned int iround, unsigned int ibit, WORD_T alpha, WORD_T beta, WORD_T gamma)
{
	// printf("-- iround = %2u, ibit = %2u, alpha = 0x%08x, beta = 0x%08x, gamma = 0x%08x\n", iround, ibit, alpha, beta, gamma); // DEBUG
    nNodes++;
    #ifdef STATS
	 bool gotChildren = false;
    nNodesPerRound[iround - 1]++;
    nNodesPerRoundPerIbit[iround - 1][ibit]++;
    #endif
    switch (iround)
    {
        case 1:
        {
            if (ibit == WORD_SIZE)
            {
                if (!((alpha == 0) && (beta == 0)))
                {
                    const int p = xdp_add_lm(alpha, beta, gamma, WORD_SIZE);
                    const WORD_T alpha_next = gamma;
                    const WORD_T beta_next = RROT(XOR(LROT(beta,gconst_r[iround-1]),RROT(gamma,gconst_s[iround-1])),gconst_r[iround]);
                    const Differential new_diff = {alpha, beta, gamma, p, p};
                    pushTrail(trail, new_diff, 0);
                    bool res = sparkle_best_trail_search_ibit0(2, alpha_next, beta_next);
                    // bool res = true;
                    if (res ==  true)
                    {
                        return true;
                    }
                    popTrail(trail, 0);
                    return false;
                }
            }
            else
            {
                const WORD_T word_size = ibit + 1;
                for (unsigned int w = 0; w < 8; w++)
                {

                    const WORD_T alpha_i = (w >> 0) & 1;
                    const WORD_T beta_i = (w >> 1) & 1;
                    const WORD_T gamma_i = (w >> 2) & 1;
                    const WORD_T alpha_next = alpha | (alpha_i << ibit);
                    const WORD_T beta_next = beta | (beta_i << ibit);
                    const WORD_T gamma_next = gamma | (gamma_i << ibit);
                    int p_part = xdp_add_lm(alpha_next, beta_next, gamma_next, word_size);
                    int p_est = p_part + g_best_B[NROUNDS - 2];
                    if (p_est >= g_Bn)
                    {
						#ifdef STATS
						gotChildren = true;
						#endif
                        bool res = sparkle_best_trail_search_i(1, ibit + 1, alpha_next, beta_next, gamma_next);
                        if (res == true)
                        {
                            return true;
                        }
                    }
                }
				#ifdef STATS
				if (gotChildren == false)
				{
					nPathsPerRoundPerIbit[iround -1][ibit]++;
				}
				#endif
                return false;
            }
        }
        break;
        default:
        // case NROUNDS:
        if (iround == NROUNDS)
        {
            if (ibit == WORD_SIZE)
            {
                const int p = xdp_add_lm(alpha, beta, gamma);
                const int cp = trail[NROUNDS - 2].cp + p;
                if (cp >= g_Bn)
                {
                    const Differential new_diff = {alpha, beta, gamma, p, cp};
                    pushTrail(trail, new_diff, NROUNDS - 1);
#if ALL_TRAILS // all trails 
						  printf("[%s:%d] Found trail with 2^%d\n", __FILE__, __LINE__, cp);
						  fprintTrail(stdout, trail);
						  fprintDifferential(stdout, trail);
						  //	assert(false);
#else // single trail
						  return true;
#endif // #if 1 // DEBUG						  
                }
				#ifdef STATS
				else
				{
					nPathsPerRoundPerIbit[iround -1][ibit]++;
				}
				#endif
            }
            else
            {
                const WORD_T word_size = ibit + 1;
                int p_trail = trail[NROUNDS - 2].cp;
                for (unsigned int w = 0; w < 2; w++)
                {
                    const WORD_T gamma_i = w;
                    const WORD_T gamma_part = gamma | (gamma_i << ibit);
                    int p_part = xdp_add_lm(alpha, beta, gamma_part, word_size);
                    int p_est = p_trail + p_part;
                    if (p_est >= g_Bn)
                    {
						#ifdef STATS
						gotChildren = true;
						#endif
                        bool res = sparkle_best_trail_search_i(NROUNDS, ibit + 1, alpha, beta, gamma_part);
                        if (res == true)
                        {
                            return true;
                        }
                    }
                }
				#ifdef STATS
				if (gotChildren == false)
				{
					nPathsPerRoundPerIbit[iround -1][ibit]++;
				}
				#endif
                return false;
            }
            break;
        }
        // default:
        {
            if (ibit == WORD_SIZE)
            {
                const int p = xdp_add_lm(alpha, beta, gamma);
                const int cp = trail[iround - 2].cp + p;
                const WORD_T alpha_next = gamma;
                const WORD_T beta_next =  RROT(XOR(LROT(beta,gconst_r[iround-1]),RROT(gamma,gconst_s[iround-1])),gconst_r[iround]);
                const Differential new_diff = {alpha, beta, gamma, p, cp};
                pushTrail(trail, new_diff, iround - 1);
                if (iround == NROUNDS - 1)
                {
                    bool res = sparkle_best_trail_search_i(iround + 1, 0, alpha_next, beta_next, 0);
                    if (res == true)
                    {
                        return true;
                    }
                }
                else
                {
                    bool res = sparkle_best_trail_search_ibit0(iround + 1, alpha_next, beta_next);
                    if (res == true)
                    {
                        return true;
                    }
                }
                popTrail(trail, iround - 1);
                return false;
            }
            else
            {
                const WORD_T word_size = ibit + 1;
                int p_trail = g_best_B[NROUNDS - iround - 1];
                p_trail += trail[iround - 2].cp;
                for (unsigned int w = 0; w < 2; w++)
                {
                    const WORD_T gamma_i = w;
                    const WORD_T gamma_part = gamma | (gamma_i << ibit);
                    int p_part = xdp_add_lm(alpha, beta, gamma_part, word_size);
                    int p_est = p_trail + p_part;
                    if (p_est >= g_Bn)
                    {
						#ifdef STATS
						gotChildren = true;
						#endif
                        bool res = sparkle_best_trail_search_i(iround, ibit + 1, alpha, beta, gamma_part);
                        if (res == true)
                        {
                            return true;
                        }
                    }
                }
				#ifdef STATS
				if (gotChildren == false)
				{
					nPathsPerRoundPerIbit[iround -1][ibit]++;
				}
				#endif
                return false;
            }
        }
        break;
    }
    return false;
}

/* wrapper to call the recursive function */
bool sparkle_best_trail_search(void)
{
	nNodes = 0;
	#ifdef STATS
	memset(nNodesPerRound, 0, NROUNDS*sizeof(uint64_t));
	for (unsigned int i = 0; i < NROUNDS; i++)
	{
	    for (unsigned int j = 0; j <= WORD_SIZE; j++)
	    {
	        nNodesPerRoundPerIbit[i][j] = 0;
	        nPathsPerRoundPerIbit[i][j] = 0;
	    }
	}
	#endif
	clearTrail(trail);
	bool res = sparkle_best_trail_search_i(1, 0, 0, 0, 0);
	return res;
}

/* First round, first bit split
 * iround = 1, ibit = 0, alpha = 0, beta = 0, gamma = 0
 */
bool sparkle_best_trail_search_split(WORD_T alpha_next, WORD_T beta_next, WORD_T gamma_next)
{
	int p_part = xdp_add_lm(alpha_next, beta_next, gamma_next, 1);
	int p_est = p_part + g_best_B[NROUNDS - 2];
	if (p_est >= g_Bn)
	{
		bool res = sparkle_best_trail_search_i(1, 1, alpha_next, beta_next, gamma_next);
		if (res == true)
		{
			return true;
		}
	}
	return false;
}
